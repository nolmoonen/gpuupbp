// Copyright (C) 2021, Nol Moonen
// Copyright (C) 2014, Petr Vevoda, Martin Sik (http://cgg.mff.cuni.cz/~sik/),
// Tomas Davidovic (http://www.davidovic.cz),
// Iliyan Georgiev (http://www.iliyan.com/),
// Jaroslav Krivanek (http://cgg.mff.cuni.cz/~jaroslav/)
//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom
// the Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// (The above is MIT License: http://en.wikipedia.origin/wiki/MIT_License)

#ifndef KERNEL_SAMPLE_CUH
#define KERNEL_SAMPLE_CUH

#include "../shared/shared_defs.h"
#include "../shared/vec_math.h"
#include "defs.cuh"

////////////////////////////////////////////////////////////////////////////////
// Cosine lobe hemisphere sampling

/// Solid angle PDF of a direction generated by cosine lobe hemisphere sampling.
__forceinline__ __device__ float
power_cos_hemisphere_pdf_w(const float3& normal, const float3& direction, const float power)
{
    const float cos_theta = fmaxf(0.f, dot(normal, direction));

    return (power + 1.f) * pow(cos_theta, power) * (INV_PI_F * .5f);
}

/// Generates a random direction via cosine lobe hemisphere sampling.
/// Optionally returns the solid angle PDF.
__forceinline__ __device__ float3 sample_power_cos_hemisphere_w(const float2& rnd, const float power, float* pdf_w)
{
    const float term1 = 2.f * PI_F * rnd.x;
    const float term2 = pow(rnd.y, 1.f / (power + 1.f));
    const float term3 = sqrtf(1.f - term2 * term2);

    if (pdf_w) *pdf_w = (power + 1.f) * pow(term2, power) * (.5f * INV_PI_F);

    return make_float3(cos(term1) * term3, sin(term1) * term3, term2);
}

////////////////////////////////////////////////////////////////////////////////
// Disc sampling

/// Samples a concentric unit disc.
__forceinline__ __device__ float2 sample_concentric_disc(const float2& rnd)
{
    float phi, r;

    float a = 2 * rnd.x - 1; /* (a,b) is now on [-1,1]^2 */
    float b = 2 * rnd.y - 1;

    if (a > -b) {
        /* region 1 or 2 */
        if (a > b) {
            /* region 1, also |a| > |b| */
            r = a;
            phi = (PI_F / 4.f) * (b / a);
        } else {
            /* region 2, also |b| > |a| */
            r = b;
            phi = (PI_F / 4.f) * (2.f - (a / b));
        }
    } else {
        /* region 3 or 4 */
        if (a < b) {
            /* region 3, also |a| >= |b|, a != 0 */
            r = -a;
            phi = (PI_F / 4.f) * (4.f + (b / a));
        } else {
            /* region 4, |b| >= |a|, but a==0 and b==0 could occur. */
            r = -b;

            if (b != 0)
                phi = (PI_F / 4.f) * (6.f - (a / b));
            else
                phi = 0;
        }
    }

    return make_float2(r * cosf(phi), r * sinf(phi));
}

/// Area PDF of sampling a position on a concentric unit disc.
__forceinline__ __device__ float concentric_disc_pdf_a() { return INV_PI_F; }

////////////////////////////////////////////////////////////////////////////////
// Cosine hemisphere sampling

/// Samples direction in the upper hemisphere with cosine-proportional PDF.
/// Optionally returns the solid angle PDF.
__forceinline__ __device__ float3 sample_cos_hemisphere_w(const float2& rnd, float* pdf_w)
{
    const float term1 = 2.f * PI_F * rnd.x;
    const float term2 = sqrtf(rnd.y);

    const float3 ret = make_float3(cosf(term1) * term2, sinf(term1) * term2, sqrtf(1.f - rnd.y));

    if (pdf_w) *pdf_w = ret.z * INV_PI_F;

    return ret;
}

/// Solid angle PDF of a direction generated by cosine hemisphere sampling.
__forceinline__ __device__ float cos_hemisphere_pdf_w(const float3& normal, const float3& direction)
{
    return fmaxf(0.f, dot(normal, direction)) * INV_PI_F;
}

/// Uniformly samples position on a triangle. Position is returned in
/// barycentric coordinates.
__forceinline__ __device__ float2 sample_uniform_triangle(const float2& rnd)
{
    const float term = sqrtf(rnd.x);
    return make_float2(1.f - term, rnd.y * term);
}

////////////////////////////////////////////////////////////////////////////////
// Sphere sampling

/// Uniformly samples direction on a unit sphere.
/// Optionally returns the solid angle PDF.
__forceinline__ __device__ float3 sample_uniform_sphere_w(const float2& rnd, float* pdf_w)
{
    const float term1 = 2.f * PI_F * rnd.x;
    const float term2 = 2.f * sqrtf(rnd.y - rnd.y * rnd.y);

    const float3 ret = make_float3(cos(term1) * term2, sin(term1) * term2, 1.f - 2.f * rnd.y);

    if (pdf_w) *pdf_w = INV_PI_F * 0.25f;

    return ret;
}

/// Solid angle PDF of a direction generated by uniform sphere sampling.
__forceinline__ __device__ float uniform_sphere_pdf_w() { return INV_PI_F * .25f; }

////////////////////////////////////////////////////////////////////////////////
// Utilities for converting PDF between Area (A) and Solid angle (W)
// w_to_a = pdf_w * cosine / distance_squared
// a_to_w = pdf_a * distance_squared / cosine

/// Solid angle PDF to area.
__forceinline__ __device__ float pdf_w_to_a(const float pdf_w, const float dist, const float cos_there)
{
    return pdf_w * fabsf(cos_there) / (dist * dist);
}

/// Area PDF to solid angle.
__forceinline__ __device__ float pdf_a_to_w(const float pdf_a, const float dist, const float cos_there)
{
    return pdf_a * (dist * dist) / fabsf(cos_there);
}

////////////////////////////////////////////////////////////////////////////////
// Misc

/// Computes sRGB luminance.
__forceinline__ __device__ float luminance(const float3& rgb)
{
    return 0.212671f * rgb.x + 0.715160f * rgb.y + 0.072169f * rgb.z;
}

/// Computes Fresnel coefficient for dielectric.
/// Takes in cosine of angle of the incoming direction and relative ior of
/// the boundary.
__forceinline__ __device__ float fresnel_dielectric(float cos_inc, float ior)
{
    if (ior < 0) return 1.f;

    float eta_inc_over_eta_trans = ior;

    if (cos_inc < 0.f) cos_inc = -cos_inc;

    const float sin_trans_2 = eta_inc_over_eta_trans * eta_inc_over_eta_trans * (1.f - cos_inc * cos_inc);
    const float cos_trans = sqrtf(fmaxf(0.f, 1.f - sin_trans_2));

    const float term1 = eta_inc_over_eta_trans * cos_trans;
    const float r_parallel = (cos_inc - term1) / (cos_inc + term1);

    const float term2 = eta_inc_over_eta_trans * cos_inc;
    const float r_perpendicular = (term2 - cos_trans) / (term2 + cos_trans);

    return 0.5f * (r_parallel * r_parallel + r_perpendicular * r_perpendicular);
}

/// Reflects direction through (0,0,1).
__forceinline__ __device__ float3 reflect_local(const float3& dir) { return make_float3(-dir.x, -dir.y, dir.z); }

#endif // KERNEL_SAMPLE_CUH
